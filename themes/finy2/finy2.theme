<?php
/**
 * @file
 * Theme functions
 */

// Include all files from the includes directory.
$includes_path = dirname(__FILE__) . '/includes/*.inc';
foreach (glob($includes_path) as $filename) {
  require_once dirname(__FILE__) . '/includes/' . basename($filename);
}

function finy2_preprocess_node(&$variables){
    // check that field event start date and end date exist
   if($variables['elements']['#node']->hasField('field_event_start_date') && $variables['elements']['#node']->hasField('field_event_end_date')){
    //kint($variables['elements']['#node']->getFieldDefinition('field_event_start_date'));
    //kint($variables['elements']['#node']->get('field_event_end_date')->getValue());
   }
   if($variables['elements']['#node']->hasField('field_date_range')){
    $date_range_array = $variables['elements']['#node']->get('field_date_range')->getValue();
    //because date is stored as UTC create date object and then set new timezone before pulling format
    $first_start_date = new DateTime($date_range_array['0']['value'], new DateTimeZone('UTC'));
    $first_start_date->setTimezone(new DateTimeZone('America/New_York'));
    $first_start_day = $first_start_date->format("l, F j, Y");
    $first_start_time = $first_start_date->format("g:i a");
    $last_end_date_array = array_pop($date_range_array);
    $last_end_date = new DateTime($last_end_date_array['end_value'], new DateTimeZone('UTC'));
    $last_end_date->setTimezone(new DateTimeZone('America/New_York'));
    $last_end_day = $last_end_date->format("l, F j, Y");
    $last_end_time = $last_end_date->format("g:i a");
    $variables['broad_date_range'] = $first_start_day." at ".$first_start_time." to ";
    //if the event has the same start and end day then just append the end time, otherwise add the final day
    if($first_start_day == $last_end_day){
      $variables['broad_date_range'] .= $last_end_time;
    }
    else{
      $variables['broad_date_range'] .= $last_end_day." at ".$last_end_time;
    }

   }
   if($variables['elements']['#node']->hasField('field_alternative_register')){
     $altRegister = $variables['elements']['#node']->get('field_alternative_register')->getName();
     kint($altRegister);
   }
   //check that field format exists for store items
   if($variables['elements']['#node']->hasField('field_format')){
      //set potential set formats to match the following taxonomy term ids for physical or downloadable audio set, downloadable/streamable video, DVD set, or subscriptions
      $sets = array('22','33', '34','36', '30');
      $variables['product_type'] = '';
      $format_values = $variables['elements']['#node']->get('field_format')->getValue();
      foreach($format_values as $value){
        if(in_array($value['target_id'], $sets)){
          $variables['product_type'] = 'set';
        }
      }
      //if none of the taxonomy ids matched then set it to single
      if($variables['product_type'] != 'set'){
        $variables['product_type'] = 'single';
      }
   //dpm($variables['product_type']);
  }
}

function finy2_preprocess_search_api_page_result(&$variables){
  if($variables['entity']->hasField('field_price')){
    //there will only ever be one price per product
    $priceArray = $variables['entity']->get('field_price')->getValue();
    $priceArray = array_shift($priceArray);
    $variables['price'] = '$'.$priceArray['value'];
  }
  if($variables['entity']->hasField('field_author_practitioner')){
    //there maybe multiple practitioners
    $practitionerArray = $variables['entity']->get('field_author_practitioner')->getValue();
    $variables['practitioner'] = '';
    foreach($practitionerArray as $key => $value){
      $tid = $value['target_id'];
      $practitioner = \Drupal\taxonomy\Entity\Term::load($tid)->name->value;
      if($key > 0){
        $variables['practitioner'] .= 'and ';
      }
      $variables['practitioner'] .= $practitioner.' ';

    }
  }
}
